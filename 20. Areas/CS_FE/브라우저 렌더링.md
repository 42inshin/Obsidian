- 쿠키: 사용자에 의해 조작되어도 크게 문제 되지 않을 정보를 브라우저에 저장
- 세션: 인증에 대한 정보를 서버에 저장
- 토큰: 인증에 대한 정보를 사용자가 저장
- 캐시: 한 번 전송받은 데이터를 저장해 놨다가 필요할 때 꺼내 쓰기 기능

### 브라우저 렌더링 과정
브라우저가 HTML을 받으면 `DOM`을 생성, CSS로 `CSSOM`을 생성. (이때 script를 만나면 렌더링이 멈추기 때문에 마지막에 위치시키거나, defer async를 붙여주는게 중요함.)
DOM과 CSSOM을 합쳐서 `렌더 트리`를 생성.
여기서 레이아웃과 페인트 단계를 거치는데, 레이아웃은 요소들의 크기를 계산해서 화면에 배치하는 단계이고, 페인트는 배치한 요소들의 컬러나 보더 형태 등의 색칠을 담당함.(요소들의 사이즈를 미리 정해놓아야 레이아웃이 수정되는 일이 적음)
요즘은 자바스크립트로 화면을 많이 조작해서 리페인트나 리플로우가 발생할 수 있는데, 리플로우는 레이아웃이 바뀌기 때문에 하위 요소들도 다 바꿔줘야 해서 계산이 많이 들어가 성능에 영향을 많이 끼친다. 그래서 리플로우를 줄이고 리페인트 위주로 하는게 최적화에 좋다.

### 브라우저에 주소를 치면 일어나는 일
브라우저에 구글 주소를 치면, 구글의 IP를 알아야 한다. 아이피를 알기 위해서는 먼저, 로컬(컴퓨터 내)에 있는 hosts파일(`local hosts file`)을 확인한다. 이 파일에 도메인, 아이피 정보가 없다면, 브라우저의 `DNS캐시`를 확인한다. 대부분의 브라우저는 이미 아는 도메인의 경우, 아이피를 저장하고 있다. 만약 없다면 `DNS 리졸브 서버`(인터넷 제공 업체 isp, 1.1.1.1, 8.8.8.8)에 접근해 도메인과 일치하는 IP정보를 찾는다. 처음에는 `루트 네임 서버`에서 찾고, 그다음에는 `TLD 네임 서버`에서 찾고, 마지막에는 `권한 네임 서버`로 가서 찾는다.
권한 네임 서버는 aws나 gcp같은거 쓸 때, 네임 서버 등록하고 A레코드 CNAME 같은거 등록하는데 그 네임 서버를 의미한다.
그러면 거기서 최종적으로 구글에 해당하는 IP를 브라우저에 전달합니다.
브라우저는 그걸 브라우저 dns캐시에 저장을 하면서, 구글닷컴에 해당하는 IP에 HTTP GET요청을 한다. 이제 진짜 구글 서버가 브라우저에 HTML을 보내준다. 
브라우저는 해당 HTML로 렌더링을 한다.

### CSR, SSR
클라이언트 사이드 렌더링, 서버 사이드 렌더링
서버에서 모든 HTML을 만들어 클라이언트로 보내주는 SSR 방식이 전통방식이었는데, 요즘은 React, Vue, Angular같은 SPA 싱글 페이지 애플리케이션이 나오면서 CSR이 유행을 탔다.
CSR은 초기에 간단한 HTML, JavaScript만 클라이언트로 보내준다. 그래서 초기로딩은 빠르다. 다만, 컨텐츠는 없다. 그때 js가 돌면서 나머지 컨텐츠들을 서버에서 불러와서 보여주는 방식이다.
SSR에 비해서 훨씬 더 앱 같은 부드러운 동작을 표현할 수 있다. 다만 전체적인 콘텐츠가 뜨는거는 훨씬
더 오래걸린다.
서버사이드 렌더링은 초기에는 컨텐츠를 완성해야 해서 느릴 수 있지만, 한방에 로딩이 된다.(캐싱하면 빠르다.)
보통 검색엔진최적화(SEO)를 위해서 SSR을 도입하곤 했는데, 요즘은 구글 봇들도 똑똑해져서 메리트가 엄청 있지는 않다.
요즘은 하이브리드로 간다. 첫페이지는 SSR로 하고 나머지는 CSR로 해서 둘의 장점을 적절하게 취하는 추세이다. (Next, Nuxt, Remix 등이 둘을 혼합해서 쓴다.)